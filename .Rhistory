do.plot = T,
main = NULL,
ylim = c(0.95, 1),
xlim = c(0.994, 1)
)
p2 <- bm_PlotEvalMean_gm(
bm.out      = spec_models,
metric.eval = c("ROC","TSS"),
group.by    = "run",
dataset = "calibration",
do.plot = T,
main = NULL,
ylim = c(0, 1),
xlim = c(0, 1)
)
saveRDS(p2, here(path_eval, "TSSfROC_runs.rds"))
ggexport(
plot = p2$plot,
filename = here(path_eval, "TSSfROC_runs.png"),
width = 1000,
height = 800,
res = 200,
units = "px",
device = "png",
limitsize = F
)
p2 <- bm_PlotEvalMean_gm(
bm.out      = spec_models,
metric.eval = c("ROC","TSS"),
group.by    = "run",
dataset = "calibration",
do.plot = T,
main = NULL,
ylim = c(0, 1),
xlim = c(0, 1)
)
saveRDS(p2, here(path_eval, "TSSfROC_runs.rds"))
ggexport(
plot = p2$plot,
filename = here(path_eval, "TSSfROC_runs.png"),
width = 1000,
height = 800,
res = 200,
units = "px",
device = "png",
limitsize = F
)
p3 <- bm_PlotEvalMean_gm(
bm.out      = spec_models,
metric.eval = c("KAPPA","TSS"),
group.by    = "algo",
dataset = "calibration",
main = NULL,
ylim = c(0, 1),
xlim = c(0, 1)
)
saveRDS(p3, here(path_eval, "TSSfKAP_algo.rds"))
ggexport(
plot = p3$plot,
filename = here(path_eval, "TSSfKAP_algo.png"),
width = 1000,
height = 800,
res = 200,
units = "px",
device = "png",
limitsize = F
)
p4 <- bm_PlotEvalMean_gm(
bm.out      = spec_models,
metric.eval = c("KAPPA","TSS"),
group.by    = "run",
dataset = "calibration",
main = NULL,
ylim = c(0, 1),
xlim = c(0, 1)
)
saveRDS(p4, here(path_eval, "TSSfKAP_runs.rds"))
ggexport(
plot = p4$plot,
filename = here(path_eval, "TSSfKAP_runs.png"),
width = 1000,
height = 800,
res = 200,
units = "px",
device = "png",
limitsize = F
)
(spec_models_var_import <- get_variables_importance(spec_models))
# calculate the mean of variable importance by algorithm
var_importance <- dcast(
spec_models_var_import,
expl.var ~ algo,
fun.aggregate = mean,
value.var = "var.imp"
)
var_importance
vmean <- (apply(var_importance[, -1], 1, mean) %>% round(3))*100
# calculate the mean of variable importance by algorithm
(spec_models_var_import <- get_variables_importance(spec_models))
var_importance <- dcast(
spec_models_var_import,
expl.var ~ algo,
fun.aggregate = mean,
value.var = "var.imp"
)
p5 <- ggplot() +
geom_col(
data = var_importance,
aes(
x = expl.var %>%
factor(
levels = expl.var[order(get(alg), decreasing = T)]
),
y = get(alg)
)
) +
xlab("Variable environnementale") +
ylab("Contribution (%)")
p5
ggexport(
plot = p5,
filename = here(path_eval, "contributions_variables.png"),
width = 1000,
height = 800,
res = 200,
units = "px",
device = "png",
limitsize = F
)
# Models response curves
# To do this we first have to load the produced models.
lapply(
all_biomod2_algos,
\(my_algo) {
glm_eval_strip <- biomod2::bm_PlotResponseCurves(
bm.out           = spec_models,
models.chosen    = BIOMOD_LoadModels(spec_models, algo = my_algo),
fixed.var        = "median",
main             = my_algo,
do.plot          = F
)
pout <- glm_eval_strip$plot +
guides(col = "none")
ggexport(
plot = pout,
filename = here(path_eval, paste0("response_curves", my_algo, ".png")),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
}
)
# Ensemble modelling
all_ensemble_algos <- c("EMcv", "EMca","EMwmean")
names(all_ensemble_algos) <- all_ensemble_algos
spec_ensemble_models <- BIOMOD_EnsembleModeling(
bm.mod               = spec_models,
em.by                = "all",
em.algo              = all_ensemble_algos,
metric.select        = "TSS"
)
(spec_ensemble_models_scores <- get_evaluations(spec_ensemble_models))
ensemble_scores_names <- c(
"metric.eval", "cutoff", "sensitivity", "specificity", "calibration"
)
# ensemble scores ----
EMscores <- all_ensemble_algos %>% lapply(
\(a) {
spec_ensemble_models_scores %>%
filter(algo == a) %>%
select(all_of(ensemble_scores_names))
}
)
thlds <- lapply(EMscores, \(tb) max(tb$cutoff, na.rm = T))
thlds[which(thlds == -Inf)] <- NA
# ensemble response curve ----
lapply(
all_ensemble_algos,
\(my_algo) {
mod_eval_strip <- biomod2::bm_PlotResponseCurves(
bm.out           = spec_ensemble_models,
models.chosen    = BIOMOD_LoadModels(
spec_ensemble_models, algo = my_algo
),
fixed.var        = "median",
main             = my_algo,
do.plot          = F
)
pout <- mod_eval_strip$plot +
guides(col = "none")
ggexport(
plot = pout,
filename = here(
path_eval, paste0("response_curves_ensemble", my_algo, ".png")),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
}
)
### Current projections ####
spec_models_proj_current <- BIOMOD_Projection(
bm.mod          = spec_models,
# new.env         = clim_sub, # mondial
new.env         = clim_proj_sub, # local
proj.name       = "current",
metric.binary   = "TSS",
output.format   = ".img",
do.stack        = FALSE
)
spec_ensemble_models_proj_current <- BIOMOD_EnsembleForecasting(
bm.em         = spec_ensemble_models,
# bm.proj       = spec_models_proj_current,
# new.env         = clim_sub, # mondial
new.env         = clim_proj_sub, # local
proj.name     = "current",
models.chosen = "all"
)
# Visualisation ----
plot(spec_ensemble_models_proj_current)
spec_proj_current_spatRast <- terra::unwrap(
spec_ensemble_models_proj_current@proj.out@val
)
path_EM <- here("data", "analysis", "models", modeling_id, "ensemble")
makeMyDir(path_EM)
path_figEM <- here(path_EM, "figures")
makeMyDir(path_figEM)
spec_pjs_plots <- mapply(
\(EMalg, col_optn) {
# EMalg <- "Cla.nod.rasterized.pca.nearest.basic.ensemble_EMcvByTSS_mergedData_mergedRun_mergedAlgo"
# col_optn <- "E"
sr <- spec_proj_current_spatRast[[EMalg]]
ps <- lapply(
islands,
\(nisl) {
# nisl <- "GLP"
# chargement des éléments du graphe
isl          <- maps[[nisl]]
e            <- ext(climatologies[[nisl]])
sr_crop      <- terra::crop(sr, e)
tb           <- as.data.frame(sr_crop, xy = T)
names(tb)[3] <- "value"
occ <- spp_sf %>% st_crop(as.vector(e)[c(1,3,2,4)])
# figures ggplot2
p <- ggplot() +
geom_tile(data = tb, aes(x = x, y = y, fill = value)) +
geom_sf(data = isl) +
scale_fill_viridis_c(option = col_optn) +
labs(x = "Longitude", y = "Latitude") +
guides(fill = guide_colorbar("Probabilité\nd'occurrence"))
pocc <- p +
geom_sf(data = occ, col = "red", shape = "+", size = 5)
# nom des fichiers de sauvegarde
file_name <- modeling_id %>%
paste(nisl, EMalg, "probability", "occurrence", "map", sep = "_") %>%
paste0(".png")
file_name_occ <- modeling_id %>%
paste(
nisl, EMalg, "probability", "occurrence", "map", "occ", sep = "_"
) %>%
paste0(".png")
# sauvegarde
ggexport(
plot = p,
filename = here(path_figEM, file_name),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
ggexport(
plot = pocc,
filename = here(path_figEM, file_name_occ),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
# préparation de la seconde carte sans certains éléments graphiques
p <- if(nisl == "MTQ") {
p +
theme(
axis.title.y = element_blank(),
axis.line.y  = element_blank(),
axis.text.y  = element_blank(),
axis.ticks.y = element_blank()
)
} else {
p + theme(legend.position = "none")
}
pocc <- if(nisl == "MTQ") {
pocc +
theme(
axis.title.y = element_blank(),
axis.line.y  = element_blank(),
axis.text.y  = element_blank(),
axis.ticks.y = element_blank()
)
} else {
pocc + theme(legend.position = "none")
}
return(list(nocc = p, pocc = pocc))
}
)
P    <- Reduce(`+`, ps %>% lapply(pluck, 1))
Pocc <- Reduce(`+`, ps %>% lapply(pluck, 2))
file_name <- modeling_id %>%
paste("ANT", EMalg, "probability", "occurrence", "map", sep = "_") %>%
paste0(".png")
file_name_occ <- modeling_id %>%
paste(
"ANT", EMalg, "probability", "occurrence", "map", "occ", sep = "_"
) %>%
paste0(".png")
ggexport(
plot = P,
filename = here(path_figEM, file_name),
width = 4200,
height = 2000,
res = 200,
units = "px",
device = "png",
limitsize = F
)
ggexport(
plot = Pocc,
filename = here(path_figEM, file_name_occ),
width = 4200,
height = 2000,
res = 200,
units = "px",
device = "png",
limitsize = F
)
return(P)
},
names(spec_proj_current_spatRast),
c("E", "C", "D"),
SIMPLIFY = F,
USE.NAMES = T
)
# Présences au-dessus d'un seuil déterminé ----
spec_inc_plots <- mapply(
\(EMalg, thld) {
# EMalg <- "Cla.nod.rasterized.pca.nearest.basic.ensemble_EMcaByTSS_mergedData_mergedRun_mergedAlgo"
# thld    <- 894
sr <- spec_proj_current_spatRast[[EMalg]]
ps <- lapply(
islands,
\(nisl) {
# chargement des éléments du graphe
isl          <- maps[[nisl]]
e            <- ext(climatologies[[nisl]])
sr_crop      <- terra::crop(sr, e)
tb           <- as.data.frame(sr_crop, xy = T)
names(tb)[3] <- "value"
occ <- bio %>%
filter(individualCount > 0) %>%
st_crop(as.vector(e)[c(1,3,2,4)])
# figures ggplot2
p <- ggplot() +
geom_tile(data = tb, aes(x = x, y = y, fill = value >= thld)) +
geom_sf(data = isl) +
scale_fill_manual(
values = c("lightblue", "darkgreen"),
labels = c("Absence", "Présence")
) +
labs(x = "Longitude", y = "Latitude") +
guides(fill = guide_legend(paste0("Seuil = ", thld)))
pocc <- p +
geom_sf(data = occ, col = "red", shape = "+", size = 5)
# noms des fichiers de sauvegarde
file_name <- modeling_id %>%
paste(nisl, EMalg, "incidence", "map", sep = "_") %>%
paste0(".png")
file_name_occ <- modeling_id %>%
paste(nisl, EMalg, "incidence", "map", "occ", sep = "_") %>%
paste0(".png")
# sauvegarde
ggexport(
plot = p,
filename = here(path_figEM, file_name),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
ggexport(
plot = pocc,
filename = here(path_figEM, file_name_occ),
width = 1000,
height = 800,
res = 100,
units = "px",
device = "png",
limitsize = F
)
# préparation de la seconde carte sans certains éléments graphiques
p <- if(nisl == "MTQ") {
p +
theme(
axis.title.y = element_blank(),
axis.line.y  = element_blank(),
axis.text.y  = element_blank(),
axis.ticks.y = element_blank()
)
} else {
p + theme(legend.position = "none")
}
pocc <- if(nisl == "MTQ") {
pocc +
theme(
axis.title.y = element_blank(),
axis.line.y  = element_blank(),
axis.text.y  = element_blank(),
axis.ticks.y = element_blank()
)
} else {
pocc + theme(legend.position = "none")
}
return(list(nocc = p, pocc = pocc))
}
)
P    <- Reduce(`+`, ps %>% lapply(pluck, 1))
Pocc <- Reduce(`+`, ps %>% lapply(pluck, 2))
file_name <- modeling_id %>%
paste("ANT", EMalg, "incidence", "map", sep = "_") %>%
paste0(".png")
file_name_occ <- modeling_id %>%
paste("ANT", EMalg, "incidence", "map", "occ", sep = "_") %>%
paste0(".png")
ggexport(
plot = P,
filename = here(path_figEM, file_name),
width = 4200,
height = 2000,
res = 200,
units = "px",
device = "png",
limitsize = F
)
ggexport(
plot = Pocc,
filename = here(path_figEM, file_name_occ),
width = 4200,
height = 2000,
res = 200,
units = "px",
device = "png",
limitsize = F
)
return(P)
},
names(spec_proj_current_spatRast)[-1],
thlds[-1],
SIMPLIFY = F,
USE.NAMES = T
)
?BIOMOD_EnsembleModeling
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/FUN/FUN_sdmOneAlgo.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_01_global_copernicus.R", echo=TRUE)
# PARAMÉTRAGE ####
# "GLM", "GBM", "GAM", "CTA", "ANN", "SRE",
# "FDA", "MARS", "RF", "MAXENT", "MAXNET"
alg <- "RF"
# Nombre de répétitions (nombre de jeux de validation croisées)
CV_nb_rep <- 5
# nom du modèle
vec_name_model <- c(paste0(tolower(alg), CV_nb_rep), "01", "global", "cpc")
pts_name_model <- paste(vec_name_model, collapse = ".")
pts_name_model
vec_name_model
modeling_id <- gsub(
" ",
".",
paste(
binnam,
paste(vec_name_model, collapse = " "),
"ensemble"
)
)
modeling_id
# Identifiant du modèle ----
modeling_id <- gsub(
" ",
".",
paste(
binnam,
paste(vec_name_model, collapse = " ")
)
)
modeling_id
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/FUN/FUN_sdmOneAlgo.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_01_global_copernicus.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_01_global_copernicus.R", echo=TRUE)
warnings()
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_02_local_sextant.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_01_global_copernicus.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_02_local_sextant.R", echo=TRUE)
source("~/Documents/mosceco/r_projects/MOSCECO_L2/habitat_suitability/scripts/sdm_1algo_Claremontiella_nodulosa_4A_03_local_habitat.R", echo=TRUE)
